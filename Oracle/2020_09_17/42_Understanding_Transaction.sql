<트랜잭션이란?>
; 트랜잭션은 반드시 함께 실행되는 작업의 단위를 의미한다.
즉 사용자의 의도에 따라 여러 개의 문장으로 구성된 트랜잭션은 반드시
동시에 실행(COMMIT)되거나 취소(ROLLBACK)된다.
RDBMS는 트랜잭션을 통해 작업의 단위를 결정함으로써 작업 결과의 신뢰성을
확보한다.

예를 들어 금융 거래 중에 계좌 이체를 생각해보자.
A라는 사람이 소유 계좌의 금액 중 100만원을 B라는 사람의 계좌로 이체한다면
최소 두 가지 작업이 수행되어야 한다.
1번째 작업은 A의 계좌에서 100만원이 출금되는 것이다.
2번째 작업은 B의 계좌에서 100만원이 입금되는 것이다.
그런데, 만약 A의 계좌에서 100만원이 출금된 이후 2번째 작업이 수행되기 전에
시스템이 다운된다면 B의 계좌에 돈이 입금되지 않고 A의 계좌에서만 100만원이
없어지게 될 수도 있다.
이런 문제를 방지하기 위해 두 개의 작업을 하나의 트랜잭션으로 묶어 놓으면
두 개의 작업이 모두 실행되지 않았을 때 모두 취소됨으로 거래의 신뢰도를
높일 수 있다.
즉, 두 번째 작업인 입금이 실행되지 않으면 첫 번째 출금 작업은 자동으로
취소되도록 함으로써 거래의 신뢰성을 확보하는 것이다.

1) 트랜잭션의 시작과 종료
 1-1) 시작
  이전 트랜잭션이 종료된 이후 DML(INSERT, UPDATE, DELETE)문장이나
  DDL(CREATE, ALTER, DROP, TRUNCATE), < 테이블 변경
  DCL(GRANT, REVOKE)문장이 실행됐을 때 시작된다. < 권한
 
 1-2) 종료
  A) COMMIT 이나 ROLLBACK 명령이 실행될 때 종료된다
  B) DDL 이나 DCL 문장의 실행이 완료되면 자동으로 종료된다
  C) 사용자의 정상 종료 시에 종료된다
  D) 데드락(DeadLock)이 걸리면 트랜잭션의 일부만 종료된다
  
 1-3) 기타
  트랜잭션은 하나의 SESSION 에서 단지 하나만 시작할 수 있다.
  DML 인 경우 반드시 COMMIT 이나 ROLLBACK 으로 종료한다
  DDL 이나 DCL 의 경우 문장이 실행되고 난 후 자동으로 종료된다.
  오라클은 SAVE POINT 명령을 이용해서 트랜잭션의 중간 과정을
  저장해놓고 복원할 수 있다.
  
2) 트랜잭션과 언두 세그먼트(UNDO SEGMEMT)
; DML 작업을 ROLLBACK 하기 위해서는 작업 이전 데이터를 어딘가에
  저장해 두어야 한다.
  오라클은 작업이 발생하면 즉시 테이블의 내용을 변경함으로
  DELETE 나 UPDATE 문을 실행하면 테이블의 정보가 즉시 변경된다.
  그러나 사용자가 ROLLBACK 을 실행하면 DML 작업에 의해서 변경된
  정보를 이전 정보로 환원해야 하는데 만일 작업 이전 정보를 저장하고
  있지 않다면 ROLLBACK 을 실행할 수 없게 된다.
  이렇게 작업 이전 정보를 저장하고 관리하는 것은 트랜잭션의 기본 기능이며
  이를 위해서 오라클은 언두 테이블스페이스와 언두 세그먼트라는 물리적인
  구조를 이용한다.
  이들은 자동으로 관리되며 사용자는 이들 정보를 직접 볼 수 없으며
  단지 트랜잭션에서만 사용된다.
  <요약>
   ORACLE : DML 명령 -> 테이블 정보 변경
                       언두 세그먼트에 이전 테이블 정보 저장
                    -> COMMIT
                       테이블 정보 확정
                       언두 세그먼트 이전 테이블 정보 삭제
   SQL-SERVER : DML 명령 -> 테이블 정보 미변경
                           명령에 의한 새로운 정보를 별도 공간에 저장
                        -> COMMIT
                           테이블 정보 변경 확정

3) 트랜잭션 과정
오라클은 INSERT(UPDATE, DELETE) 문이 실행될 때 행이 입력된다
그리고 입력된 행에만 잠금이 걸린다(독점 잠금)
COMMIT 시 잠금이 풀린다

EX) 테이블의 데이터 5를 7로 UPDATE 하는 과정
1) UPDATE 문장이 테이블에 발생하면, 문장 수행을 위해 사용할
   UNDO SEGMENT 를 결정한다
2) 테이블에 저장되어있던 원래 값(5)를 UNDO SEGMENT 에 저장한다
3) UPDATE 된 값(7)이 테이블에 저장된다
4) 값이 변경된 행은 독점 잠금(Exclusive Lock)이 발생된다
5) 해당 행이 존재하는 테이블은 공유 잠금(Share Lock)이 발생된다
6) 트랜잭션이 COMMIT 되면 잠금은 모두 해제되고 변경된 값(7)은
   영구히 저장된다.
7) 트랜잭션이 ROLLBACK 되면 UNDO SEGMENT 에 저장했던 원래 값(5)를
   테이블로 환원하고 잠금이 해제된다.
   
<독점 잠금(Exclusive Lock)과 공유 잠금(Share Lock)>
1) 독점 잠금 : 다른 세션의 접근을 불허한다
              다른 세션은 해당 행을 검색할 수 없고,
              UNDO SEGMENT 에 있는 정보만 보게 된다
2) 공유 잠금 : DDL(ALTER, DROP) 작업을 방지한다              